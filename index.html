<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Survive 60s</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0e14; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display:block; width:100vw; height:100vh; }

    .hud {
      position:fixed; inset:0; pointer-events:none; color:#ffffff;
      display:flex; flex-direction:column; padding:14px;
      text-shadow: 0 2px 6px rgba(0,0,0,.85);
    }
    .top { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; flex-wrap:wrap; }

    .pill{
      pointer-events:none;
      display:inline-flex; gap:10px; align-items:center;
      padding:10px 12px; border-radius:999px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
    }
    .pill b { font-weight:900; color:#ffffff; letter-spacing:.2px; }
    .pill span { color: rgba(255,255,255,.95); }

    .langPill{
      pointer-events:auto;
      user-select:none;
    }
    .langBtn{
      pointer-events:auto;
      cursor:pointer;
      appearance:none;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.10);
      color:#ffffff;
      padding:6px 10px;
      border-radius:999px;
      font-weight:900;
    }
    .langBtn.active{
      background:#ffffff;
      color:#0b0e14;
      border-color: rgba(255,255,255,.35);
    }

    .centerOverlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }

    /* ✅ KEY FIX: set default text color for everything inside overlay */
    .card {
      pointer-events:auto;
      width:min(720px, calc(100vw - 24px));
      padding:18px 18px 14px;
      border-radius:16px;
      background: rgba(20,22,28,.88);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
      color: rgba(255,255,255,.92); /* ✅ THIS fixes black text everywhere */
    }

    .card h1{
      margin: 0 0 10px;
      font-size: 24px;
      font-weight: 950;
      color:#ffffff;
      text-shadow: 0 2px 8px rgba(0,0,0,.85);
      letter-spacing: .2px;
    }

    .card p{
      margin:0 0 14px;
      color: rgba(255,255,255,.92);
      line-height: 1.45;
      text-shadow: 0 1px 4px rgba(0,0,0,.75);
      white-space: pre-line;
    }

    .btnRow { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    button {
      pointer-events:auto;
      appearance:none; border:0; border-radius:12px;
      padding:10px 12px; font-weight:950; cursor:pointer;
      background: #e9eefc; color:#0b0e14;
    }
    button.secondary {
      background: rgba(233,238,252,.14);
      color:#ffffff;
      border:1px solid rgba(233,238,252,.18);
    }
    button.danger {
      background: rgba(255, 107, 138, .18);
      color:#ffffff;
      border:1px solid rgba(255, 107, 138, .25);
    }
    button:disabled{
      opacity:.5;
      cursor:not-allowed;
    }
    button:active { transform: translateY(1px); }

    .small {
      font-size: 12px;
      color: rgba(255,255,255,.75);
      text-shadow: 0 1px 3px rgba(0,0,0,.7);
    }

    .hintBar {
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      padding:10px 12px; border-radius:999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
      pointer-events:none;
      color: rgba(255,255,255,.95);
      max-width: min(820px, calc(100vw - 24px));
      text-align:center;
      text-shadow: 0 2px 6px rgba(0,0,0,.85);
      white-space: pre-line;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 680px){
      .grid2{ grid-template-columns: 1fr; }
    }

    /* ✅ KEY FIX: make panels and rows explicitly white */
    .panel{
      padding: 12px 12px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.92); /* ✅ ensures no black text */
    }
    .panel h2{
      margin: 0 0 8px;
      font-size: 14px;
      font-weight: 950;
      letter-spacing: .2px;
      color: rgba(255,255,255,.95);
    }
    .row{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items:center;
      padding: 8px 0;
      border-top: 1px solid rgba(255,255,255,.08);
      color: rgba(255,255,255,.92); /* ✅ ensures row text stays bright */
    }
    .row:first-of-type{ border-top: 0; padding-top: 0; }

    /* ✅ KEY FIX: bold text and numbers always white */
    .row b, .mono b { color:#ffffff; }
    .row span { color: rgba(255,255,255,.92); }

    .mono{ font-variant-numeric: tabular-nums; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="top">
      <div class="pill"><b id="lblTime">Time</b> <span class="mono" id="time">60.0</span>s</div>
      <div class="pill"><b id="lblScore">Score</b> <span class="mono" id="score">0</span></div>
      <div class="pill"><b id="lblHp">HP</b> <span class="mono" id="hp">100</span></div>
      <div class="pill"><b id="lblCoins">Coins</b> <span class="mono" id="coins">0</span></div>

      <div class="pill langPill" style="margin-left:auto;">
        <b id="lblLang">Lang</b>
        <button class="langBtn" id="langEN" type="button">EN</button>
        <button class="langBtn" id="langRU" type="button">RU</button>
      </div>
    </div>
  </div>

  <div class="centerOverlay" id="overlay" style="display:flex;">
    <div class="card" id="card"></div>
  </div>

  <div class="hintBar" id="hint" style="display:none;"></div>

<script>
(() => {
  // ======================
  // Survive 60s — improved version:
  // ✅ Better UI contrast (fixed panels/rows black text bug)
  // ✅ English + Russian with language switch
  // ✅ Best score + coins + local leaderboard (top 10)
  // ✅ Daily challenge (rotates daily)
  // ✅ Light upgrades (speed/damage/hp) with caps
  // ✅ 4 enemy archetypes (tank, fast, splitter, dasher)
  // ✅ Ad hooks kept as STUBS
  // ======================

  // ---------- Language ----------
  const I18N = {
    en: {
      hud_time: "Time",
      hud_score: "Score",
      hud_hp: "HP",
      hud_coins: "Coins",
      hud_lang: "Lang",

      menu_title: "Survive 60 seconds",
      menu_text: "Move to dodge. You auto-attack nearby enemies.\nOne revive available after 40s.",
      menu_start: "Start",
      menu_how: "How to play",
      menu_upgrades: "Upgrades",
      menu_leaderboard: "Leaderboard",
      menu_controls: "Controls: WASD / Arrow keys • Mobile: drag to move • Restart: Space/Enter",

      daily_title: "Daily Challenge",
      daily_complete: "Daily reward claimed today.",
      daily_claim: "Claim reward",
      daily_reward: (n)=> `Reward: +${n} coins`,
      daily_rule_speed: "+20% enemy speed",
      daily_rule_score: "Fast enemies give +50% score",
      daily_rule_fragile: "Start with 70 HP",
      daily_rule_dense: "More spawns after 30s",

      how_title: "How to play",
      how_text:
        "Goal: Survive 60 seconds.\n" +
        "Move to dodge enemies.\n" +
        "You auto-attack the nearest enemy in range.\n\n" +
        "After 45 seconds the pressure spikes — that’s the fun part.",
      how_back: "Back",
      how_tip: "Tip: move in arcs, not straight lines.",

      up_title: "Upgrades",
      up_sub: "Small upgrades = more fun. Caps keep the game fair.",
      up_speed: "Move Speed",
      up_dmg: "Damage",
      up_hp: "Max HP",
      up_level: (lv, cap)=> `Level ${lv}/${cap}`,
      up_buy: "Buy",
      up_notenough: "Not enough coins",
      up_reset: "Reset progress",
      up_reset_confirm: "Reset all progress? (coins, upgrades, best score, leaderboard)",

      lb_title: "Leaderboard (local)",
      lb_empty: "No runs yet. Play once and you’ll appear here.",
      lb_rank: "Rank",
      lb_points: "Score",
      lb_date: "Date",
      lb_back: "Back",

      dead_title: (sec) => `You died at ${sec.toFixed(1)}s`,
      dead_text: "Revive once and continue? (Best value after 40s)",
      revive_yes: "Revive (Rewarded)",
      revive_no: "No thanks",
      dead_tip: "Tip: late waves spike after 45s — keep moving.",

      end_win_title: "You survived 60s!",
      end_lose_title: "Run ended",
      end_win_text: "Nice. Can you beat your best score?",
      end_lose_text: "One more try — your brain adapts fast.",
      end_again: "Play again",
      end_menu: "Main menu",
      end_restart: "Restart instantly: Space / Enter",
      end_best: (n)=> `Best: ${n}`,
      end_earned: (n)=> `Coins earned: +${n}`,

      hint_start: "Survive 60s.\nRevive available after 40s.",
      hint_shield: "Shield active!",
      hint_saved: "Saved!",
      hint_daily: "Daily reward claimed!"
    },
    ru: {
      hud_time: "Время",
      hud_score: "Счёт",
      hud_hp: "HP",
      hud_coins: "Монеты",
      hud_lang: "Язык",

      menu_title: "Выжить 60 секунд",
      menu_text: "Двигайся, чтобы уклоняться. Ты автоматически атакуешь ближайших врагов.\nОдин ревив доступен после 40 секунд.",
      menu_start: "Играть",
      menu_how: "Как играть",
      menu_upgrades: "Улучшения",
      menu_leaderboard: "Таблица",
      menu_controls: "Управление: WASD / Стрелки • Мобайл: тяни для движения • Рестарт: Space/Enter",

      daily_title: "Ежедневное испытание",
      daily_complete: "Ежедневная награда уже получена.",
      daily_claim: "Забрать награду",
      daily_reward: (n)=> `Награда: +${n} монет`,
      daily_rule_speed: "+20% скорость врагов",
      daily_rule_score: "Быстрые враги дают +50% очков",
      daily_rule_fragile: "Старт с 70 HP",
      daily_rule_dense: "Больше спавна после 30с",

      how_title: "Как играть",
      how_text:
        "Цель: выжить 60 секунд.\n" +
        "Двигайся, чтобы уклоняться от врагов.\n" +
        "Ты автоматически атакуешь ближайшего врага в радиусе.\n\n" +
        "После 45 секунд давление резко растёт — вот где кайф.",
      how_back: "Назад",
      how_tip: "Совет: двигайся дугами, не по прямой.",

      up_title: "Улучшения",
      up_sub: "Небольшие улучшения = больше кайфа. Лимиты сохраняют баланс.",
      up_speed: "Скорость",
      up_dmg: "Урон",
      up_hp: "Макс HP",
      up_level: (lv, cap)=> `Уровень ${lv}/${cap}`,
      up_buy: "Купить",
      up_notenough: "Не хватает монет",
      up_reset: "Сброс прогресса",
      up_reset_confirm: "Сбросить всё? (монеты, улучшения, рекорд, таблица)",

      lb_title: "Таблица (локально)",
      lb_empty: "Пока нет результатов. Сыграй один раз — и появишься здесь.",
      lb_rank: "Место",
      lb_points: "Очки",
      lb_date: "Дата",
      lb_back: "Назад",

      dead_title: (sec) => `Ты погиб на ${sec.toFixed(1)}с`,
      dead_text: "Ревив один раз и продолжить? (Лучше всего после 40с)",
      revive_yes: "Ревив (Награда)",
      revive_no: "Не нужно",
      dead_tip: "Совет: после 45с волны усиливаются — двигайся постоянно.",

      end_win_title: "Ты выжил 60 секунд!",
      end_lose_title: "Забег окончен",
      end_win_text: "Отлично. Сможешь побить рекорд?",
      end_lose_text: "Ещё раз — мозг учится быстро.",
      end_again: "Ещё раз",
      end_menu: "Меню",
      end_restart: "Быстрый рестарт: Space / Enter",
      end_best: (n)=> `Рекорд: ${n}`,
      end_earned: (n)=> `Монеты: +${n}`,

      hint_start: "Выживи 60с.\nРевив доступен после 40с.",
      hint_shield: "Щит активен!",
      hint_saved: "Сохранено!",
      hint_daily: "Награда получена!"
    }
  };

  // ---------- Storage ----------
  const LS = {
    COINS: "s60_coins",
    BEST: "s60_best",
    UP: "s60_upgrades",
    LB: "s60_lb",
    LANG: "s60_lang",
    DAILY_DATE: "s60_daily_date",
    DAILY_TYPE: "s60_daily_type",
    DAILY_CLAIMED: "s60_daily_claimed",
  };

  function detectLang() {
    const saved = localStorage.getItem(LS.LANG);
    if (saved === "en" || saved === "ru") return saved;
    const nav = (navigator.language || "en").toLowerCase();
    return nav.startsWith("ru") ? "ru" : "en";
  }
  let lang = detectLang();
  const t = (key, ...args) => {
    const v = I18N[lang][key];
    return typeof v === "function" ? v(...args) : v;
  };

  function loadInt(key, def=0){
    const v = parseInt(localStorage.getItem(key) || "", 10);
    return Number.isFinite(v) ? v : def;
  }
  function saveInt(key, v){ localStorage.setItem(key, String(Math.max(0, Math.floor(v)))); }

  function loadJSON(key, def){
    try{
      const s = localStorage.getItem(key);
      if (!s) return def;
      return JSON.parse(s);
    }catch{ return def; }
  }
  function saveJSON(key, obj){ localStorage.setItem(key, JSON.stringify(obj)); }

  const UPGRADE_CAP = { speed: 4, dmg: 4, hp: 3 };
  const UPGRADE_COST = {
    speed: [120, 220, 360, 540],
    dmg:   [140, 260, 420, 620],
    hp:    [180, 320, 520]
  };

  function getUpgrades(){
    const def = { speed:0, dmg:0, hp:0 };
    const u = loadJSON(LS.UP, def);
    return { speed: u.speed|0, dmg: u.dmg|0, hp: u.hp|0 };
  }
  function setUpgrades(u){ saveJSON(LS.UP, u); }

  function getCoins(){ return loadInt(LS.COINS, 0); }
  function setCoins(n){ saveInt(LS.COINS, n); }
  function addCoins(n){ setCoins(getCoins() + n); }

  function getBest(){ return loadInt(LS.BEST, 0); }
  function setBest(n){ saveInt(LS.BEST, n); }

  function getLB(){ return loadJSON(LS.LB, []); }
  function setLB(arr){ saveJSON(LS.LB, arr); }

  function addToLB(score){
    const arr = getLB();
    const date = new Date().toISOString().slice(0,10);
    arr.push({ score, date });
    arr.sort((a,b)=> b.score - a.score);
    setLB(arr.slice(0, 10));
  }

  // ---------- Daily Challenge ----------
  function todayKey(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }

  function ensureDaily(){
    const tk = todayKey();
    const stored = localStorage.getItem(LS.DAILY_DATE);
    if (stored !== tk){
      localStorage.setItem(LS.DAILY_DATE, tk);
      const seed = (tk.split("-").join(""));
      const n = parseInt(seed, 10);
      const type = Number.isFinite(n) ? (n % 4) : Math.floor(Math.random()*4);
      localStorage.setItem(LS.DAILY_TYPE, String(type));
      localStorage.setItem(LS.DAILY_CLAIMED, "0");
    }
  }
  ensureDaily();

  function getDailyType(){ return loadInt(LS.DAILY_TYPE, 0) % 4; }
  function isDailyClaimed(){ return loadInt(LS.DAILY_CLAIMED, 0) === 1; }
  function setDailyClaimed(){ localStorage.setItem(LS.DAILY_CLAIMED, "1"); }

  function dailyRuleText(type){
    if (type === 0) return t("daily_rule_speed");
    if (type === 1) return t("daily_rule_score");
    if (type === 2) return t("daily_rule_fragile");
    return t("daily_rule_dense");
  }

  function dailyRewardAmount(){ return 200; }

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const uiTime = document.getElementById('time');
  const uiScore = document.getElementById('score');
  const uiHp = document.getElementById('hp');
  const uiCoins = document.getElementById('coins');

  const lblTime = document.getElementById('lblTime');
  const lblScore = document.getElementById('lblScore');
  const lblHp = document.getElementById('lblHp');
  const lblCoins = document.getElementById('lblCoins');
  const lblLang = document.getElementById('lblLang');

  const btnEN = document.getElementById('langEN');
  const btnRU = document.getElementById('langRU');

  const overlay = document.getElementById('overlay');
  const card = document.getElementById('card');
  const hint = document.getElementById('hint');

  function setLang(newLang) {
    if (newLang !== "en" && newLang !== "ru") return;
    lang = newLang;
    localStorage.setItem(LS.LANG, newLang);
    applyHudText();
    if (state.mode === "menu") goMenu();
    else if (state.mode === "dead" || state.mode === "win") showEndScreen(state.mode === "win");
    else if (state.mode === "upgrades") showUpgrades();
    else if (state.mode === "leaderboard") showLeaderboard();
    else if (state.mode === "how") showHow();
  }

  btnEN.addEventListener("click", () => setLang("en"));
  btnRU.addEventListener("click", () => setLang("ru"));

  function applyHudText() {
    lblTime.textContent = t("hud_time");
    lblScore.textContent = t("hud_score");
    lblHp.textContent = t("hud_hp");
    lblCoins.textContent = t("hud_coins");
    lblLang.textContent = t("hud_lang");
    btnEN.classList.toggle("active", lang === "en");
    btnRU.classList.toggle("active", lang === "ru");
  }
  applyHudText();

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- Utils ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, tt) => a + (b - a) * tt;
  const rand = (a, b) => a + Math.random() * (b - a);
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.key.toLowerCase());
    if ((e.key === ' ' || e.key === 'Enter') && (state.mode === 'dead' || state.mode === 'win')) restart();
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  let touchActive = false;
  let touchStart = { x: 0, y: 0 };
  let touchPos = { x: 0, y: 0 };
  window.addEventListener('pointerdown', (e) => {
    touchActive = true;
    touchStart = { x: e.clientX, y: e.clientY };
    touchPos = { x: e.clientX, y: e.clientY };
  });
  window.addEventListener('pointermove', (e) => {
    if (!touchActive) return;
    touchPos = { x: e.clientX, y: e.clientY };
  });
  window.addEventListener('pointerup', () => { touchActive = false; });

  // ---------- Game State ----------
  const state = {
    mode: 'menu',
    t: 0,
    timeLeft: 60,
    score: 0,
    shake: 0,
    lastNow: performance.now(),
    accumulator: 0,
    dtFixed: 1/120,
    usedRevive: false,
    canRevive: false,
    interstitialCounter: 0,
  };

  const world = {
    w: () => window.innerWidth,
    h: () => window.innerHeight,
    cx: () => window.innerWidth / 2,
    cy: () => window.innerHeight / 2,
  };

  const player = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    r: 14,
    hp: 100, maxHp: 100,
    speed: 260,
    invuln: 0,
    atkCooldown: 0,
    atkRate: 0.18,
    atkRange: 110,
    atkDamage: 14,
  };

  const enemies = [];
  const bullets = [];
  const particles = [];
  const floaters = [];

  const ENEMY_MAX = 140;

  function applyUpgradesToPlayer(){
    const u = getUpgrades();
    const speedMul = 1 + 0.03 * u.speed;
    const dmgAdd = 2 * u.dmg;
    const hpAdd = 10 * u.hp;

    player.speed = 260 * speedMul;
    player.atkDamage = 14 + dmgAdd;
    player.maxHp = 100 + hpAdd;
  }

  function resetEntities() {
    enemies.length = 0;
    bullets.length = 0;
    particles.length = 0;
    floaters.length = 0;

    applyUpgradesToPlayer();

    player.x = world.cx();
    player.y = world.cy();
    player.vx = 0; player.vy = 0;

    const dt = getDailyType();
    let startHP = player.maxHp;
    if (dt === 2) startHP = Math.min(startHP, 70);
    player.hp = startHP;

    player.invuln = 1.2;
    player.atkCooldown = 0;

    state.t = 0;
    state.timeLeft = 60;
    state.score = 0;
    state.shake = 0;
    state.usedRevive = false;
    state.canRevive = false;
  }

  function difficultyCurve(tt) {
    const a = clamp(tt / 60, 0, 1);
    const spike = clamp((tt - 35) / 25, 0, 1);

    let spawn = lerp(0.9, 2.2, a) + lerp(0, 2.0, spike);
    if (getDailyType() === 3 && tt > 30) spawn *= 1.25;

    let speedMul = lerp(0.9, 1.35, a) + lerp(0, 0.55, spike);
    if (getDailyType() === 0) speedMul *= 1.20;

    const fastChance = lerp(0.06, 0.24, a) + lerp(0, 0.18, spike);
    const splitterChance = lerp(0.05, 0.16, a);
    const dasherChance = lerp(0.04, 0.12, a);

    return { spawn, speedMul, fastChance, splitterChance, dasherChance };
  }

  let spawnAccum = 0;

  function spawnEnemy(tt) {
    if (enemies.length >= ENEMY_MAX) return;

    const { speedMul, fastChance, splitterChance, dasherChance } = difficultyCurve(tt);

    const margin = 60;
    const side = Math.floor(Math.random()*4);
    let x, y;
    if (side === 0) { x = rand(-margin, world.w()+margin); y = -margin; }
    if (side === 1) { x = world.w()+margin; y = rand(-margin, world.h()+margin); }
    if (side === 2) { x = rand(-margin, world.w()+margin); y = world.h()+margin; }
    if (side === 3) { x = -margin; y = rand(-margin, world.h()+margin); }

    const r = Math.random();
    let type = "tank";
    if (r < fastChance) type = "fast";
    else if (r < fastChance + splitterChance) type = "splitter";
    else if (r < fastChance + splitterChance + dasherChance) type = "dasher";

    let radius, baseSpeed, hp, dmg, knockResist;

    if (type === "fast"){
      radius = 11; baseSpeed = 150; hp = 26; dmg = 10; knockResist = 0.6;
    } else if (type === "splitter"){
      radius = 14; baseSpeed = 120; hp = 46; dmg = 12; knockResist = 0.45;
    } else if (type === "dasher"){
      radius = 13; baseSpeed = 110; hp = 40; dmg = 13; knockResist = 0.5;
    } else {
      radius = 15; baseSpeed = 105; hp = 44; dmg = 14; knockResist = 0.3;
    }

    enemies.push({
      x, y, vx: 0, vy: 0,
      r: radius,
      hp, maxHp: hp,
      speed: baseSpeed * speedMul,
      dmg,
      knockResist,
      type,
      dashCD: rand(1.3, 2.2),
      dashing: 0
    });
  }

  function spawnMini(x, y, speedMul){
    if (enemies.length >= ENEMY_MAX) return;
    enemies.push({
      x, y, vx: 0, vy: 0,
      r: 9,
      hp: 16, maxHp: 16,
      speed: 165 * speedMul,
      dmg: 8,
      knockResist: 0.65,
      type: "mini",
      dashCD: 999, dashing: 0
    });
  }

  function addParticles(x, y, count) {
    for (let i=0; i<count; i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(40, 220);
      particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        life: rand(0.18, 0.45),
        age: 0,
        r: rand(1.2, 2.6),
      });
    }
  }
  function addFloater(x, y, text) {
    floaters.push({ x, y, vy: -40, age: 0, life: 0.7, text });
  }

  // ---------- Ads (STUBS) ----------
  async function showRewardedAdStub() { return new Promise((resolve) => setTimeout(() => resolve(true), 450)); }
  async function showInterstitialAdStub() { return new Promise((resolve) => setTimeout(() => resolve(true), 350)); }

  function applyPlayerInput(dt) {
    let ix = 0, iy = 0;
    if (keys.has('w') || keys.has('arrowup')) iy -= 1;
    if (keys.has('s') || keys.has('arrowdown')) iy += 1;
    if (keys.has('a') || keys.has('arrowleft')) ix -= 1;
    if (keys.has('d') || keys.has('arrowright')) ix += 1;

    if (touchActive) {
      const dx = touchPos.x - touchStart.x;
      const dy = touchPos.y - touchStart.y;
      const len = Math.hypot(dx, dy);
      if (len > 8) { ix = dx / len; iy = dy / len; }
    }

    const len = Math.hypot(ix, iy) || 1;
    ix /= len; iy /= len;

    const targetVx = ix * player.speed;
    const targetVy = iy * player.speed;
    player.vx = lerp(player.vx, targetVx, 1 - Math.pow(0.001, dt));
    player.vy = lerp(player.vy, targetVy, 1 - Math.pow(0.001, dt));

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    player.x = clamp(player.x, player.r, world.w() - player.r);
    player.y = clamp(player.y, player.r, world.h() - player.r);
  }

  function autoAttack(dt) {
    player.atkCooldown -= dt;
    if (player.atkCooldown > 0) return;

    let best = -1;
    let bestD = Infinity;
    const range2 = player.atkRange * player.atkRange;

    for (let i=0; i<enemies.length; i++) {
      const e = enemies[i];
      const d = dist2(player.x, player.y, e.x, e.y);
      if (d < range2 && d < bestD) { bestD = d; best = i; }
    }
    if (best === -1) return;

    const e = enemies[best];
    player.atkCooldown = player.atkRate;

    const dx = e.x - player.x;
    const dy = e.y - player.y;
    const len = Math.hypot(dx, dy) || 1;

    bullets.push({
      x: player.x + (dx/len) * (player.r + 6),
      y: player.y + (dy/len) * (player.r + 6),
      vx: (dx/len) * 900,
      vy: (dy/len) * 900,
      life: 0.06,
      age: 0,
      dmg: player.atkDamage,
    });
  }

  function updateBullets(dt) {
    for (let i=bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.age += dt;
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      for (let j=enemies.length-1; j>=0; j--) {
        const e = enemies[j];
        const rr = (e.r + 6) * (e.r + 6);
        if (dist2(b.x, b.y, e.x, e.y) < rr) {
          e.hp -= b.dmg;
          addParticles(b.x, b.y, 10);
          addFloater(e.x, e.y - 10, `-${b.dmg}`);

          const dx = e.x - player.x;
          const dy = e.y - player.y;
          const len = Math.hypot(dx, dy) || 1;
          const kb = 220 * (1 - e.knockResist);
          e.vx += (dx/len) * kb;
          e.vy += (dy/len) * kb;

          state.shake = Math.min(8, state.shake + 2.5);
          bullets.splice(i, 1);
          break;
        }
      }

      if (i < bullets.length) {
        if (b.age >= b.life) bullets.splice(i, 1);
      }
    }
  }

  function scoreForKill(e){
    let s = 10;
    if (e.type === "fast") s = 14;
    if (e.type === "mini") s = 8;
    if (e.type === "splitter") s = 12;
    if (e.type === "dasher") s = 12;
    if (getDailyType() === 1 && e.type === "fast") s = Math.round(s * 1.5);
    return s;
  }

  function updateEnemies(dt) {
    const { speedMul } = difficultyCurve(state.t);

    for (let i=enemies.length-1; i>=0; i--) {
      const e = enemies[i];

      if (e.hp <= 0) {
        if (e.type === "splitter") {
          spawnMini(e.x + rand(-8, 8), e.y + rand(-8, 8), speedMul);
          spawnMini(e.x + rand(-8, 8), e.y + rand(-8, 8), speedMul);
        }

        state.score += scoreForKill(e);
        addParticles(e.x, e.y, 18);
        enemies.splice(i, 1);
        continue;
      }

      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const len = Math.hypot(dx, dy) || 1;

      let targetSpeed = e.speed;

      if (e.type === "dasher") {
        e.dashCD -= dt;
        if (e.dashCD <= 0) {
          e.dashing = 0.35;
          e.dashCD = rand(1.4, 2.2);
          addParticles(e.x, e.y, 10);
        }
        if (e.dashing > 0) {
          e.dashing -= dt;
          targetSpeed *= 2.2;
        }
      }

      const ax = (dx/len) * targetSpeed;
      const ay = (dy/len) * targetSpeed;

      e.vx = lerp(e.vx, ax, 1 - Math.pow(0.002, dt));
      e.vy = lerp(e.vy, ay, 1 - Math.pow(0.002, dt));
      e.vx *= Math.pow(0.06, dt);
      e.vy *= Math.pow(0.06, dt);

      e.x += e.vx * dt;
      e.y += e.vy * dt;

      const rr = (player.r + e.r) * (player.r + e.r);
      if (dist2(player.x, player.y, e.x, e.y) < rr) {
        if (player.invuln <= 0) {
          player.hp -= e.dmg;
          player.invuln = 0.35;
          state.shake = Math.min(12, state.shake + 6);
          addParticles(player.x, player.y, 22);
          addFloater(player.x, player.y - 16, `-${e.dmg}`);

          const px = (player.x - e.x);
          const py = (player.y - e.y);
          const plen = Math.hypot(px, py) || 1;
          player.x += (px/plen) * 10;
          player.y += (py/plen) * 10;
        }
      }
    }
  }

  function updateParticles(dt) {
    for (let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.age += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.08, dt);
      p.vy *= Math.pow(0.08, dt);
      if (p.age >= p.life) particles.splice(i, 1);
    }
    for (let i=floaters.length-1; i>=0; i--) {
      const f = floaters[i];
      f.age += dt;
      f.y += f.vy * dt;
      if (f.age >= f.life) floaters.splice(i, 1);
    }
  }

  function updateGame(dt) {
    state.t += dt;
    state.timeLeft = Math.max(0, 60 - state.t);
    state.canRevive = (!state.usedRevive && state.t >= 40);

    const { spawn } = difficultyCurve(state.t);
    spawnAccum += spawn * dt;
    while (spawnAccum >= 1) {
      spawnAccum -= 1;
      spawnEnemy(state.t);
    }

    if (player.invuln > 0) player.invuln -= dt;

    applyPlayerInput(dt);
    autoAttack(dt);
    updateBullets(dt);
    updateEnemies(dt);
    updateParticles(dt);

    if (player.hp <= 0) { player.hp = 0; endRun(false); }
    else if (state.timeLeft <= 0) endRun(true);
  }

  function setHint(text) {
    hint.textContent = text;
    hint.style.display = text ? 'block' : 'none';
  }
  function showOverlay(html) {
    card.innerHTML = html;
    overlay.style.display = 'flex';
  }
  function hideOverlay() { overlay.style.display = 'none'; }

  function overlayLangButtonsInline() {
    const enActive = lang === "en" ? "active" : "";
    const ruActive = lang === "ru" ? "active" : "";
    return `
      <div class="btnRow" style="margin-bottom:10px;">
        <span class="small" style="margin-right:8px;">${t("hud_lang")}:</span>
        <button class="langBtn ${enActive}" id="ovEN" type="button">EN</button>
        <button class="langBtn ${ruActive}" id="ovRU" type="button">RU</button>
      </div>
    `;
  }
  function wireOverlayLangButtons() {
    const ovEN = document.getElementById("ovEN");
    const ovRU = document.getElementById("ovRU");
    if (ovEN) ovEN.onclick = () => setLang("en");
    if (ovRU) ovRU.onclick = () => setLang("ru");
  }

  function formatDate(d){ return d; }

  // ---------- Screens ----------
  function goMenu() {
    state.mode = 'menu';
    ensureDaily();

    const best = getBest();
    const coins = getCoins();
    const dailyType = getDailyType();
    const claimed = isDailyClaimed();
    const reward = dailyRewardAmount();

    showOverlay(`
      ${overlayLangButtonsInline()}
      <h1>${t("menu_title")}</h1>
      <p>${t("menu_text")}</p>

      <div class="grid2" style="margin: 10px 0 12px;">
        <div class="panel">
          <h2>${t("daily_title")}</h2>
          <div class="row"><span>${dailyRuleText(dailyType)}</span><span class="small mono">${t("daily_reward", reward)}</span></div>
          <div class="btnRow" style="margin-top:8px;">
            <button id="claimDailyBtn" type="button" ${claimed ? "disabled" : ""}>${claimed ? t("daily_complete") : t("daily_claim")}</button>
          </div>
        </div>

        <div class="panel">
          <h2>Progress</h2>
          <div class="row"><span><b>${t("hud_coins")}:</b></span><span class="mono"><b>${coins}</b></span></div>
          <div class="row"><span><b>${t("end_best", best)}</b></span><span class="small mono">Top10 local</span></div>
          <div class="btnRow" style="margin-top:8px;">
            <button class="secondary" id="openUpBtn" type="button">${t("menu_upgrades")}</button>
            <button class="secondary" id="openLbBtn" type="button">${t("menu_leaderboard")}</button>
          </div>
        </div>
      </div>

      <div class="btnRow">
        <button id="startBtn" type="button">${t("menu_start")}</button>
        <button class="secondary" id="howBtn" type="button">${t("menu_how")}</button>
      </div>

      <p class="small" style="margin-top:10px;">${t("menu_controls")}</p>
    `);

    wireOverlayLangButtons();

    document.getElementById("startBtn").onclick = () => start();
    document.getElementById("howBtn").onclick = () => showHow();
    document.getElementById("openUpBtn").onclick = () => showUpgrades();
    document.getElementById("openLbBtn").onclick = () => showLeaderboard();

    const claimBtn = document.getElementById("claimDailyBtn");
    if (claimBtn && !claimed){
      claimBtn.onclick = () => {
        addCoins(reward);
        setDailyClaimed();
        uiCoins.textContent = String(getCoins());
        setHint(t("hint_daily"));
        setTimeout(() => setHint(""), 1200);
        goMenu();
      };
    }
  }

  function showHow() {
    state.mode = "how";
    showOverlay(`
      ${overlayLangButtonsInline()}
      <h1>${t("how_title")}</h1>
      <p>${t("how_text")}</p>
      <div class="btnRow">
        <button id="backBtn" type="button">${t("how_back")}</button>
      </div>
      <p class="small" style="margin-top:10px;">${t("how_tip")}</p>
    `);
    wireOverlayLangButtons();
    document.getElementById('backBtn').onclick = () => goMenu();
  }

  function showUpgrades(){
    state.mode = "upgrades";
    const u = getUpgrades();
    const coins = getCoins();

    function upRow(key, label){
      const cap = UPGRADE_CAP[key];
      const lv = u[key];
      const nextCost = lv < cap ? UPGRADE_COST[key][lv] : null;
      const disabled = (lv >= cap) || (nextCost !== null && coins < nextCost);
      const costText = lv >= cap ? "MAX" : `${nextCost} ${t("hud_coins")}`;
      const btnText = lv >= cap ? "MAX" : t("up_buy");
      return `
        <div class="row">
          <div>
            <b>${label}</b>
            <div class="small">${t("up_level", lv, cap)}</div>
          </div>
          <div style="text-align:right;">
            <div class="small mono">${costText}</div>
            <button id="buy_${key}" type="button" ${disabled ? "disabled" : ""}>${btnText}</button>
          </div>
        </div>
      `;
    }

    showOverlay(`
      ${overlayLangButtonsInline()}
      <h1>${t("up_title")}</h1>
      <p>${t("up_sub")}</p>

      <div class="panel">
        <h2>${t("hud_coins")}: <span class="mono"><b>${coins}</b></span></h2>
        ${upRow("speed", t("up_speed"))}
        ${upRow("dmg", t("up_dmg"))}
        ${upRow("hp", t("up_hp"))}
      </div>

      <div class="btnRow" style="margin-top:12px;">
        <button class="secondary" id="upBack" type="button">${t("how_back")}</button>
        <button class="danger" id="resetAll" type="button">${t("up_reset")}</button>
      </div>

      <p class="small" style="margin-top:10px;">
        ${t("daily_title")}: ${dailyRuleText(getDailyType())}
      </p>
    `);

    wireOverlayLangButtons();
    document.getElementById("upBack").onclick = () => goMenu();

    document.getElementById("resetAll").onclick = () => {
      if (confirm(t("up_reset_confirm"))){
        localStorage.removeItem(LS.COINS);
        localStorage.removeItem(LS.BEST);
        localStorage.removeItem(LS.UP);
        localStorage.removeItem(LS.LB);
        setHint(t("hint_saved"));
        setTimeout(() => setHint(""), 900);
        goMenu();
      }
    };

    ["speed","dmg","hp"].forEach(key=>{
      const btn = document.getElementById(`buy_${key}`);
      if (!btn) return;
      btn.onclick = () => {
        const uu = getUpgrades();
        const cap = UPGRADE_CAP[key];
        if (uu[key] >= cap) return;
        const cost = UPGRADE_COST[key][uu[key]];
        const c = getCoins();
        if (c < cost) return;
        setCoins(c - cost);
        uu[key] += 1;
        setUpgrades(uu);
        applyUpgradesToPlayer();
        setHint(t("hint_saved"));
        setTimeout(() => setHint(""), 900);
        showUpgrades();
      };
    });
  }

  function showLeaderboard(){
    state.mode = "leaderboard";
    const lb = getLB();
    const rows = lb.length
      ? lb.map((r, idx)=>`
          <div class="row">
            <div class="mono"><b>#${idx+1}</b></div>
            <div class="mono" style="margin-left:auto;"><b>${r.score}</b></div>
            <div class="small mono" style="min-width:92px; text-align:right;">${formatDate(r.date)}</div>
          </div>
        `).join("")
      : `<p class="small">${t("lb_empty")}</p>`;

    showOverlay(`
      ${overlayLangButtonsInline()}
      <h1>${t("lb_title")}</h1>
      <div class="panel">
        <h2>${t("lb_rank")} • ${t("lb_points")} • ${t("lb_date")}</h2>
        ${rows}
      </div>
      <div class="btnRow" style="margin-top:12px;">
        <button class="secondary" id="lbBack" type="button">${t("lb_back")}</button>
      </div>
    `);
    wireOverlayLangButtons();
    document.getElementById("lbBack").onclick = () => goMenu();
  }

  function start() {
    resetEntities();
    spawnAccum = 0;
    state.mode = 'playing';
    hideOverlay();
    setHint(t("hint_start"));
    setTimeout(() => setHint(''), 1800);
  }

  function restart() {
    resetEntities();
    spawnAccum = 0;
    state.mode = 'playing';
    hideOverlay();
    setHint('');
  }

  async function maybeShowInterstitial() {
    state.interstitialCounter++;
    const show = (state.interstitialCounter % 3 === 0) || (state.interstitialCounter % 5 === 0);
    if (show) await showInterstitialAdStub();
  }

  function computeCoinsEarned(win){
    const base = Math.floor(state.score / 6);
    const timeBonus = Math.floor((60 - state.timeLeft) / 10) * 6;
    const winBonus = win ? 120 : 0;
    return Math.max(5, base + timeBonus + winBonus);
  }

  async function endRun(win) {
    if (state.mode !== 'playing') return;
    state.mode = win ? 'win' : 'dead';

    if (!win && state.canRevive) {
      const sec = Math.max(0, 60 - state.timeLeft);
      showOverlay(`
        ${overlayLangButtonsInline()}
        <h1>${t("dead_title", sec)}</h1>
        <p>${t("dead_text")}</p>
        <div class="btnRow">
          <button id="reviveBtn" type="button">${t("revive_yes")}</button>
          <button class="secondary" id="noBtn" type="button">${t("revive_no")}</button>
        </div>
        <p class="small" style="margin-top:10px;">${t("dead_tip")}</p>
      `);
      wireOverlayLangButtons();

      document.getElementById('reviveBtn').onclick = async () => {
        const ok = await showRewardedAdStub();
        if (ok) {
          state.usedRevive = true;
          player.hp = Math.max(35, Math.floor(player.maxHp * 0.40));
          player.invuln = 2.2;
          enemies.splice(0, Math.floor(enemies.length * 0.35));
          addParticles(player.x, player.y, 40);
          hideOverlay();
          state.mode = 'playing';
          setHint(t("hint_shield"));
          setTimeout(() => setHint(''), 1200);
        } else {
          showEndScreen(win);
        }
      };
      document.getElementById('noBtn').onclick = () => showEndScreen(win);
      return;
    }

    showEndScreen(win);
  }

  async function showEndScreen(win) {
    const earned = computeCoinsEarned(win);
    addCoins(earned);

    if (state.score > getBest()) setBest(state.score);
    addToLB(state.score);

    await maybeShowInterstitial();

    const title = win ? t("end_win_title") : t("end_lose_title");
    const subtitle = win ? t("end_win_text") : t("end_lose_text");
    const newBest = getBest();

    showOverlay(`
      ${overlayLangButtonsInline()}
      <h1>${title}</h1>
      <p>${subtitle}</p>

      <div class="grid2" style="margin: 10px 0 12px;">
        <div class="panel">
          <h2>${t("hud_score")}</h2>
          <div class="row"><span><b>${t("hud_score")}:</b></span><span class="mono"><b>${state.score}</b></span></div>
          <div class="row"><span><b>${t("end_best", newBest)}</b></span><span class="small mono">Top10 local</span></div>
        </div>
        <div class="panel">
          <h2>${t("hud_coins")}</h2>
          <div class="row"><span><b>${t("hud_coins")}:</b></span><span class="mono"><b>${getCoins()}</b></span></div>
          <div class="row"><span><b>${t("end_earned", earned)}</b></span><span class="small mono">${dailyRuleText(getDailyType())}</span></div>
        </div>
      </div>

      <div class="btnRow">
        <button id="againBtn" type="button">${t("end_again")}</button>
        <button class="secondary" id="menuBtn" type="button">${t("end_menu")}</button>
        <button class="secondary" id="openLbBtn2" type="button">${t("menu_leaderboard")}</button>
      </div>

      <p class="small" style="margin-top:10px;">${t("end_restart")}</p>
    `);
    wireOverlayLangButtons();

    document.getElementById('againBtn').onclick = () => restart();
    document.getElementById('menuBtn').onclick = () => goMenu();
    document.getElementById('openLbBtn2').onclick = () => showLeaderboard();
  }

  // ---------- Rendering ----------
  function render() {
    const w = window.innerWidth, h = window.innerHeight;

    state.shake = Math.max(0, state.shake - 20 * state.dtFixed);
    const sx = (Math.random()*2 - 1) * state.shake;
    const sy = (Math.random()*2 - 1) * state.shake;

    ctx.save();
    ctx.translate(sx, sy);

    ctx.fillStyle = '#0b0e14';
    ctx.fillRect(0, 0, w, h);

    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#cfe0ff';
    ctx.lineWidth = 1;
    const grid = 48;
    ctx.beginPath();
    for (let x = 0; x < w; x += grid) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
    for (let y = 0; y < h; y += grid) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    for (const p of particles) {
      const tt = 1 - (p.age / p.life);
      ctx.globalAlpha = tt;
      ctx.fillStyle = '#e9eefc';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    for (const b of bullets) {
      ctx.strokeStyle = 'rgba(233,238,252,.85)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(b.x - b.vx*0.012, b.y - b.vy*0.012);
      ctx.stroke();
    }

    for (const e of enemies) {
      let color = '#ff6b8a';
      if (e.type === 'fast') color = '#ffdf6e';
      if (e.type === 'mini') color = '#ffd3e0';
      if (e.type === 'splitter') color = '#a6b7ff';
      if (e.type === 'dasher') color = '#7bf2ff';

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#0b0e14';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r+2, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;

      const hpT = clamp(e.hp / e.maxHp, 0, 1);
      ctx.strokeStyle = 'rgba(233,238,252,.75)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r+2, -Math.PI/2, -Math.PI/2 + hpT * Math.PI*2);
      ctx.stroke();

      if (e.type === "dasher" && e.dashing > 0) {
        ctx.globalAlpha = 0.28;
        ctx.strokeStyle = '#7bf2ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r+6, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    const inv = player.invuln > 0 ? 0.45 : 1;
    ctx.globalAlpha = inv;
    ctx.fillStyle = '#7cf0c3';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    if (state.mode === 'playing') {
      const tt = clamp((state.t - 42)/18, 0, 1);
      ctx.globalAlpha = 0.06 + 0.06 * tt;
      ctx.strokeStyle = '#7cf0c3';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.atkRange, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = 'rgba(233,238,252,.95)';
    ctx.font = '900 13px system-ui';
    for (const f of floaters) {
      const a = 1 - (f.age / f.life);
      ctx.globalAlpha = a;
      ctx.fillText(f.text, f.x + 10, f.y);
    }
    ctx.globalAlpha = 1;

    const nearEnd = clamp((state.t - 45) / 15, 0, 1);
    if (nearEnd > 0) {
      const grd = ctx.createRadialGradient(player.x, player.y, 60, player.x, player.y, Math.max(w,h));
      grd.addColorStop(0, 'rgba(0,0,0,0)');
      grd.addColorStop(1, `rgba(255,64,96,${0.12 * nearEnd})`);
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,w,h);
    }

    ctx.restore();
  }

  function frame(now) {
    const delta = Math.min(0.05, (now - state.lastNow) / 1000);
    state.lastNow = now;
    state.accumulator += delta;

    uiTime.textContent = state.timeLeft.toFixed(1);
    uiScore.textContent = String(state.score);
    uiHp.textContent = String(Math.max(0, Math.floor(player.hp)));
    uiCoins.textContent = String(getCoins());

    while (state.accumulator >= state.dtFixed) {
      state.accumulator -= state.dtFixed;
      if (state.mode === 'playing') updateGame(state.dtFixed);
    }

    render();
    requestAnimationFrame(frame);
  }

  // boot
  resetEntities();
  goMenu();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
